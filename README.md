# @selfage/observable

## Install

`npm install @selfage/observable`

## Overview

Written in TypeScript and compiled to ES6 with inline source map & source. See [@selfage/tsconfig](https://www.npmjs.com/package/@selfage/tsconfig) for full compiler options. Provides a runtime lib to be used together with `ObservableDescriptor` generated by `@selfage/generator_cli`, which can parse, copy and merge observable objects.

An observable object exposes events/callbacks to observe every state change.

See [@selfage/generator_cli#observable](https://github.com/selfage/generator_cli#observable) for how to generate `ObservableDescriptor`. We will continue using the example generated.

## Listen on observable object

Changes are detected through TypeScript setter. Events are emitted via NodeJs's `EventEmitter`.

```TypeScript
import { BasicData } from './basic'; // Generated by @selfage/generator_cli.
import { ObservableArray } from '@selfage/observable_array';

let basicData = new BasicData();
basicData.on('numberField', (newValue, oldValue) => {
  console.log(`newValue: ${newValue}; oldValue: ${oldValue};`);
});
basicData.numberField = 10;
// Print: newValue: 10; oldValue: undefined;
basicData.numberField = 100;
// Print: newValue: 100; oldValue: 10;
delete basicData.numberField;
// Actually does nothing. basicData.numberField is still 100.
basicData.numberField = undefined;
// Print: newValue: undefined; oldValue: 100;

basicData.on('stringArrayField', (newValue, oldValue) => {
  console.log(`newValue: ${JSON.stringify(newValue)}; oldValue: ${JSON.stringify(oldValue)};`);
});
basicData.stringArrayField = ['str1', 'str2'];
// Print: newValue: ['str1','str2']; oldValue: undefined;
basicData.stringArrayField = ['str1', 'str2'];
// Print: newValue: ['str1','str2']; oldValue: ['str1','str2'];
// This is because the new and old ObservableArray's are not the instance. I.e., they are not equal by `===`.
basicData.stringArrayField.push('str3');
// Nothing to print as changes are not bubbled up.

basicData.on('observableArrayField', (newValue, oldValue) => {
  console.log(`newValue: ${JSON.stringify(newValue)}; oldValue: ${JSON.stringify(oldValue)};`);
});
basicData.observableArrayField = ObservableArray.of(true, false);
// Print: newValue: [true,false]; oldValue: undefined;
basicData.observableArrayField.push(false);
// Nothing to print as changes are not bubbled up.
```

In order to observe arrays, please add a listener on `basicData.observableArrayField` directly. Refer to package `@selfage/observable_array` for explanation.

Changes on `BasicData` are not bubbled up either, even if you nest `BasicData` inside another observable object. Always add listeners on nested observable objects directly.

## Parse observable objects at runtime

You might not create an observable object directly, and parse a parse a JSON-parsed object into an observable object as the following.

```TypeScript
import { parseObservable } from '@selfage/observable/parser'; // Generated by @selfage/generator_cli.
import { BASIC_DATA, BasicData } from './basic'; // As generated from the example above.

let raw = JSON.parse(`{ "numberField": 111, "otherField": "random", "stringArrayField": ["str1", "str2"] }`);
let basicData = parseObservable(raw, BASIC_DATA); // Of type `BasicData`.
```

## Trigger initial events

If you have created an observable object before you could add listeners to it, you can trigger initial events, such that listeners called as if each field is just assigned with the new value.

```TypeScript
import { BASIC_DATA, BasicData } from './basic'; // Generated by @selfage/generator_cli.

let data = new BasicData();
data.numberField = 111;
data.triggerInitialEvents();
// Emit `numberField` event with newValue as 111, and oldValue as undefined.
// A special 'init' event will also be triggered which passes nothing to the listener. It can be used to flip undefined fields.
```

## Design considerations for observable object

We have also provided `@selfage/observable_js` in pure JavaScript to convert any objects into observable objects via ES6 proxy. The main reason we didn't do the same thing in TypeScript is that we failed to find a way to make the converted observable objects type-safe. I.e., what would be the return type for function `toObservable<T>(obj: T): ?` requring `on(event: '<field name>', listener:...)` to be added to `T` and can be type checked by TypeScript?

As for why we didn't allow bubbling up changes, it's because:

1. Our main use case is to observe changes on states to trigger UI changes, where each component can own its own observable object. Nested objects should be observed by nested components. It could be messy to ignore nested objects.
2. If you want to push new states into browser history, you probably don't want to push upon every single change, because an operation might trigger multiple changes which should be grouped into one history entry.
